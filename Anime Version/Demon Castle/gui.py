# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage
import pyvista as pv
import subprocess
import csv
import ujson
import cv2
from PIL import Image, ImageTk
import random
import threading
import sys
import os
import numpy as np
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
import tkinter as tk
from pyopengltk import OpenGLFrame
from OpenGL.GLUT import glutInit
from math import sin, cos, pi
import random
from raid_interface import RaidInterface

current_dir = os.path.dirname(os.path.abspath(__file__))

project_root = os.path.abspath(os.path.join(current_dir, '../../'))

sys.path.insert(0, project_root)

import thesystem.misc
# âœ¨ NEW: Helper function to load player stats
def load_player_stats():
    try:
        with open("Files/Player Data/Status.json", 'r') as f:
            data = ujson.load(f)
            # Ensure the highest_floor key exists
            if "highest_floor" not in data["status"][0]:
                data["status"][0]["highest_floor"] = 0
            return data
    except (FileNotFoundError, IndexError):
        # Return default stats if file is missing or malformed
        return {"status": [{"highest_floor": 0}]}

def draw_cube(size=1.0):
    half = size / 2
    glBegin(GL_QUADS)
    # Front
    glVertex3f(-half, -half, half)
    glVertex3f( half, -half, half)
    glVertex3f( half,  half, half)
    glVertex3f(-half,  half, half)
    # Back
    glVertex3f(-half, -half, -half)
    glVertex3f(-half,  half, -half)
    glVertex3f( half,  half, -half)
    glVertex3f( half, -half, -half)
    # Left
    glVertex3f(-half, -half, -half)
    glVertex3f(-half, -half,  half)
    glVertex3f(-half,  half,  half)
    glVertex3f(-half,  half, -half)
    # Right
    glVertex3f(half, -half, -half)
    glVertex3f(half,  half, -half)
    glVertex3f(half,  half,  half)
    glVertex3f(half, -half,  half)
    # Top
    glVertex3f(-half, half, -half)
    glVertex3f(-half, half,  half)
    glVertex3f( half, half,  half)
    glVertex3f( half, half, -half)
    # Bottom
    glVertex3f(-half, -half, -half)
    glVertex3f( half, -half, -half)
    glVertex3f( half, -half,  half)
    glVertex3f(-half, -half,  half)
    glEnd()


def draw_cylinder(radius=1.0, height=2.0, slices=32):
    # Cylinder walls
    glBegin(GL_QUAD_STRIP)
    for i in range(slices+1):
        theta = 2 * pi * i / slices
        x = radius * cos(theta)
        z = radius * sin(theta)
        glVertex3f(x, 0, z)
        glVertex3f(x, height, z)
    glEnd()

    # Top cap
    glBegin(GL_TRIANGLE_FAN)
    glVertex3f(0, height, 0)
    for i in range(slices+1):
        theta = 2 * pi * i / slices
        x = radius * cos(theta)
        z = radius * sin(theta)
        glVertex3f(x, height, z)
    glEnd()

    # Bottom cap
    glBegin(GL_TRIANGLE_FAN)
    glVertex3f(0, 0, 0)
    for i in range(slices+1):
        theta = 2 * pi * i / slices
        x = radius * cos(theta)
        z = radius * sin(theta)
        glVertex3f(x, 0, z)
    glEnd()

def draw_building_block(size=1.0, window_size=0.15, num_windows=3, highlight=False):
    """
    Draws a building block with evenly spaced windows.

    Args:
        size (float): The overall size of the cube.
        window_size (float): The size of each square window.
        num_windows (int): The number of windows per side.
        highlight (bool): Whether to draw the block in a highlighted color.
    """
    half = size / 2
    
    # Set wall colors based on highlight state
    if highlight:
        wall_color = (0.9, 0.8, 0.2)
        side_wall_color = (0.8, 0.7, 0.1)
    else:
        wall_color = (0.2, 0.2, 0.25)
        side_wall_color = (0.15, 0.15, 0.2)

    # --- NEW: Calculate even spacing ---
    # Total width taken by all windows
    total_window_width = num_windows * window_size
    # Remaining space for gaps
    remaining_space = size - total_window_width
    # There will be (num_windows + 1) gaps (including edges)
    gap_size = remaining_space / (num_windows + 1)
    # --- END NEW ---

    # Draw the main walls
    for face in ['front', 'back', 'left', 'right']:
        glBegin(GL_QUADS)
        if face in ['front', 'back']:
            glColor3fv(wall_color)
        else:
            glColor3fv(side_wall_color)
        
        if face == 'front':
            glVertex3f(-half, -half, half); glVertex3f(half, -half, half)
            glVertex3f(half, half, half); glVertex3f(-half, half, half)
        elif face == 'back':
            glVertex3f(-half, -half, -half); glVertex3f(-half, half, -half)
            glVertex3f(half, half, -half); glVertex3f(half, -half, -half)
        elif face == 'left':
            glVertex3f(-half, -half, -half); glVertex3f(-half, -half, half)
            glVertex3f(-half, half, half); glVertex3f(-half, half, -half)
        elif face == 'right':
            glVertex3f(half, -half, -half); glVertex3f(half, half, -half)
            glVertex3f(half, half, half); glVertex3f(half, -half, half)
        glEnd()

        # Draw evenly spaced windows
        glColor3f(0.1, 0.1, 0.15)
        w_half = window_size / 2
        
        # --- MODIFIED: Use a for loop with calculated positions ---
        for i in range(num_windows):
            # Calculate the center x-position for the current window
            x = -half + gap_size + (i * (window_size + gap_size)) + w_half
            for j in range(num_windows):
                # Calculate the center y-position for the current window
                y = -half + gap_size + (j * (window_size + gap_size)) + w_half
                
                glBegin(GL_QUADS)
                if face == 'front':
                    glVertex3f(x - w_half, y - w_half, half + 0.01); glVertex3f(x + w_half, y - w_half, half + 0.01)
                    glVertex3f(x + w_half, y + w_half, half + 0.01); glVertex3f(x - w_half, y + w_half, half + 0.01)
                elif face == 'back':
                    # Note: For the back face, the x-coordinates are flipped
                    glVertex3f(-x + w_half, y - w_half, -half - 0.01); glVertex3f(-x - w_half, y - w_half, -half - 0.01)
                    glVertex3f(-x - w_half, y + w_half, -half - 0.01); glVertex3f(-x + w_half, y + w_half, -half - 0.01)
                elif face == 'left':
                    # Here, 'x' from the loop corresponds to the z-axis in 3D space
                    glVertex3f(-half - 0.01, y - w_half, x - w_half); glVertex3f(-half - 0.01, y + w_half, x - w_half)
                    glVertex3f(-half - 0.01, y + w_half, x + w_half); glVertex3f(-half - 0.01, y - w_half, x + w_half)
                elif face == 'right':
                    # Flipped z-axis for the right side
                    glVertex3f(half + 0.01, y - w_half, -x + w_half); glVertex3f(half + 0.01, y + w_half, -x + w_half)
                    glVertex3f(half + 0.01, y + w_half, -x - w_half); glVertex3f(half + 0.01, y - w_half, -x - w_half)
                glEnd()
        # --- END MODIFIED ---

    # Draw the top and bottom faces of the block
    glColor3f(0.1, 0.1, 0.1)
    glBegin(GL_QUADS)
    # Top
    glVertex3f(-half, half, -half); glVertex3f(-half, half, half)
    glVertex3f(half, half, half); glVertex3f(half, half, -half)
    # Bottom
    glVertex3f(-half, -half, -half); glVertex3f(half, -half, -half)
    glVertex3f(half, -half, half); glVertex3f(-half, -half, half)
    glEnd()


class Castle3D(OpenGLFrame):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        self.animate = 1
        self.angle = 0
        self.particles = []
        self.floors = []
        self.section_status = {}

        self.camera_y = 0.0
        self.target_camera_y = 0.0
        
        player_stats = load_player_stats()["status"][0]
        self.highest_floor_cleared = player_stats.get("highest_floor", 0) 
        self.current_scroll_floor = self.highest_floor_cleared + 1 # Start view on the next floor
        
        self.setup_tower(100, self.highest_floor_cleared)
        self.init_particles(500)

        # Set initial camera position
        self.target_camera_y = self.floors[self.current_scroll_floor - 1]['y_center']

        self.hud_frame = tk.Frame(self, bg="#111111")
        self.hud_status_label = tk.Label(self.hud_frame, text="", font=("Helvetica", 16), bg="#111111", fg="white", justify=tk.LEFT)
        self.hud_status_label.pack(pady=5, padx=10)
        
        self.hud_raid_button = tk.Button(self.hud_frame, text="Raid Floor", font=("Helvetica", 14), bg="#900", fg="white", command=self.raid_floor)
        self.hud_raid_button.pack(pady=10, padx=10, fill=tk.X)
        
        self.update_hud()
        self.raid_floor_callback = None

    def raid_floor(self):
        floor_num = self.current_scroll_floor
        if self.raid_floor_callback:
            self.raid_floor_callback(floor_num)
            
    def on_key_press(self, event):
        if event.keysym == 'Up':
            self.current_scroll_floor = min(len(self.floors), self.current_scroll_floor + 1)
        elif event.keysym == 'Down':
            self.current_scroll_floor = max(1, self.current_scroll_floor - 1)
        
        self.target_camera_y = self.floors[self.current_scroll_floor - 1]['y_center']
        self.update_hud()
        


    def update_hud(self):
        floor_num = self.current_scroll_floor
        status = "Unknown"
        color = "white"

        if floor_num <= self.highest_floor_cleared:
            status = "CLEARED"
            color = "#555555" # Grey for cleared
        elif floor_num == self.highest_floor_cleared + 1:
            status = "UNLOCKED"
            color = "#00FF00" # Green for next
        else:
            status = "LOCKED"
            color = "#FF0000" # Red for locked

        status_text = f"FLOOR {floor_num}: {status}"
        self.hud_status_label.config(text=status_text, fg=color)
        
        # --- MODIFIED LOGIC HERE ---
        # Show the raid button if the floor is not locked.
        if status == "UNLOCKED" or status == "CLEARED":
            self.hud_raid_button.pack(pady=10, padx=10, fill=tk.X)
        else:
            self.hud_raid_button.pack_forget()
            
        self.hud_frame.place(relx=0.02, rely=0.02)


    def setup_tower(self, num_floors, highest_floor_cleared):
        self.floors = []
        current_y = 0
        for i in range(num_floors):
            height = 4
            scale_factor = 1.0 - (i / (num_floors * 1.5))
            width = 8 * scale_factor
            depth = 8 * scale_factor
            self.floors.append({
                'num': i + 1, 'y_bottom': current_y, 'y_top': current_y + height,
                'y_center': current_y + height / 2, 'width': width, 'depth': depth, 'height': height
            })
            current_y += height
    
    # --- Other class methods like on_click, initgl, etc. remain unchanged ---
    
    def on_click(self, event):
        # NEW: Advanced picking logic
        if self.camera_mode == 'orbiting':
            # We need the current projection and modelview matrices to use gluProject
            modelview = glGetDoublev(GL_MODELVIEW_MATRIX)
            projection = glGetDoublev(GL_PROJECTION_MATRIX)
            viewport = glGetIntegerv(GL_VIEWPORT)

            click_y = viewport[3] - event.y  # OpenGL Y is bottom-up

            for floor in self.floors:
                # Project the 3D top and bottom of the floor to 2D screen coordinates
                bottom_screen_pos = gluProject(0, floor['y_bottom'], 0, modelview, projection, viewport)
                top_screen_pos = gluProject(0, floor['y_top'], 0, modelview, projection, viewport)

                # Check if the click Y is between the floor's screen Y coordinates
                if bottom_screen_pos[1] < click_y < top_screen_pos[1]:
                    self.focused_section = floor['num']
                    self.camera_mode = 'focused'
                    
                    status_text = self.section_status.get(self.focused_section, "Unknown")
                    self.info_label.config(text=status_text)
                    self.info_label.place(relx=0.5, rely=0.1, anchor=tk.CENTER)
                    return # Exit after finding the clicked floor

        elif self.camera_mode == 'focused':
            self.camera_mode = 'orbiting'
            self.focused_section = None
            self.info_label.place_forget()



    def initgl(self):
        glEnable(GL_DEPTH_TEST)
        glClearColor(0.05, 0.0, 0.0, 1.0) # Darker red background

        # --- NEW LIGHTING SETUP ---
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        glEnable(GL_COLOR_MATERIAL)
        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE)

        light_pos = [20.0, 30.0, 20.0, 1.0] # Positional light from above-right
        light_ambient = [0.3, 0.3, 0.3, 1.0]
        light_diffuse = [0.9, 0.9, 0.9, 1.0]
        
        glLightfv(GL_LIGHT0, GL_POSITION, light_pos)
        glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient)
        glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse)
        # --- END NEW LIGHTING ---

        glEnable(GL_FOG)
        glFogi(GL_FOG_MODE, GL_EXP2)
        glFogfv(GL_FOG_COLOR, (0.1, 0.0, 0.0, 1.0))
        glFogf(GL_FOG_DENSITY, 0.05)

        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        gluPerspective(45, self.width / self.height, 0.1, 200.0)
        glMatrixMode(GL_MODELVIEW)
    


    def init_particles(self, num_particles):
        for _ in range(num_particles):
            particle = {
                'pos': [random.uniform(-15, 15), random.uniform(0, 25), random.uniform(-15, 15)],
                'vel': [random.uniform(-0.01, 0.01), random.uniform(0.01, 0.05), random.uniform(-0.01, 0.01)],
                'life': random.uniform(1, 5)
            }
            self.particles.append(particle)

    def manage_particles(self):
        glPointSize(3.0) # Set the size of the points
        glColor4f(0.8, 0.8, 0.9, 0.7) # Faint white color
        
        glBegin(GL_POINTS)
        for p in self.particles:
            # 1. Update position and life
            p['pos'][0] += p['vel'][0]
            p['pos'][1] += p['vel'][1]
            p['pos'][2] += p['vel'][2]
            p['life'] -= 0.01

            glColor4f(random.uniform(0.8, 1.0), random.uniform(0.2, 0.6), 0.1, 0.8)
            # ...
            if p['life'] <= 0:
                # Reset particles from the ground
                p['pos'] = [random.uniform(-15, 15), 0, random.uniform(-15, 15)]
                p['life'] = random.uniform(1, 5)
            
            # 3. Draw the particle
            glVertex3fv(p['pos'])
        glEnd()



    def redraw(self):
        if not self.winfo_exists():
            return
        self.angle += 0.2
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glLoadIdentity()
        
        # --- Default Camera: Orbiting Scroll ---
        self.camera_y += (self.target_camera_y - self.camera_y) * 0.1
        
        radius = 15.0
        eyeX = radius * cos(self.angle * pi / 180.0)
        eyeZ = radius * sin(self.angle * pi / 180.0)
        
        gluLookAt(eyeX, self.camera_y, eyeZ, 0, self.camera_y, 0, 0, 1, 0)

        # --- Drawing Logic (Unchanged) ---
        # Ground
        glColor3f(0.1, 0.1, 0.1)
        glBegin(GL_QUADS)
        glVertex3f(-100, -1, -100); glVertex3f(100, -1, -100)
        glVertex3f(100, -1, 100); glVertex3f(-100, -1, 100)
        glEnd()

        self.manage_particles()

        # Procedurally draw all floors with highlighting
        for floor in self.floors:
            is_highlighted = (floor['num'] == self.current_scroll_floor)
            glPushMatrix()
            glTranslatef(0, floor['y_center'], 0)
            glScalef(floor['width'], floor['height'], floor['depth'])
            draw_building_block(size=1.0, window_size=0.15, num_windows=4, highlight=is_highlighted)
            glPopMatrix()


# --- The rest of the gui.py file from this point down is largely unchanged ---
# --- except for the end_raid function. ---


current_dir = os.path.dirname(os.path.abspath(__file__))

project_root = os.path.abspath(os.path.join(current_dir, '../../'))

sys.path.insert(0, project_root)

import thesystem.system
import thesystem.castle
import thesystem.misc as misc

OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"assets\frame0")

open_check=misc.update_screen("Castle")

run_once_val=False

# Path to the ujson file
ujson_file_path = "Files/Player Data/image_visibility.json"

# Load visibility data
data = thesystem.castle.load_image_visibility(ujson_file_path, run_once_val)

hidden_images=data[0]
floor=data[1]

# Create images and set visibility
file_num=0

try:
    with open("Files/Data/Demon_Castle.json", 'r') as castle_file:
        castle_data = ujson.load(castle_file)
except:
    with open("Files/Data/Demon_Castle.json", 'w') as castle_file:
        castle_data={"Souls":0,"XP":0,"Rewards":False,"Final":False}
        ujson.dump(castle_data,castle_file, indent=4)

try:
    with open("Files/Player Data/Demon_Castle.json", 'r') as castle_file:
        castle_data = ujson.load(castle_file)
except:
    try:
        with open("Files/Data/Demon_Castle.json", 'r') as castle_file0:
            castle_data0 = ujson.load(castle_file0)
    except:
        castle_data0={"Souls":0,"XP":0,"Rewards":False,"Final":False}
    with open("Files/Player Data/Demon_Castle.json", 'w') as castle_file:
        castle_data=castle_data0
        ujson.dump(castle_data,castle_file, indent=4)

def relative_to_assets(path: str) -> Path:
    global file_num

    file_num+=1
    if file_num>=53 or file_num<4:
        return ASSETS_PATH / Path(path)
    
    with open(ujson_file_path, 'r') as fr:
        reading_data=ujson.load(fr)
        fin_data=reading_data["hidden_images"]
    
    int_list = list(map(int, fin_data))
    check=False
    if file_num in int_list:
        check=reading_data["hidden_images"][str(file_num)]["Completed"]

    if check==True:
        pat = ASSETS_PATH / Path("image_4.png")
        return pat
    else:
        pat = ASSETS_PATH / Path("image_5.png")
        return pat

with open("Files/Mod/presets.json", 'r') as pres_file:
    pres_file_data=ujson.load(pres_file)
    get_stuff_path_str=pres_file_data["Anime"]["High Long Size"]

def get_stuff_path(key):
    full_path=get_stuff_path_str+'/'+key
    return full_path
glutInit()

window = Tk()

initial_height = 0
target_height = 602
window_width = 1102

window.geometry(f"{window_width}x{initial_height}")
stop_event=threading.Event()

job=thesystem.misc.return_status()["status"][1]["job"]

top_val='dailyquest.py'
all_prev=''
video='Video'
transp_clr='#0C679B'

if job!='None':
    top_val=''
    all_prev='alt_'
    video='Alt Video'
    transp_clr='#652AA3'

thesystem.system.make_window_transparent(window, transp_clr)

with open("Files/Player Data/Settings.json", 'r') as settings_open:
    setting_data=ujson.load(settings_open)

top_images = f"thesystem/{all_prev}top_bar"
bottom_images = f"thesystem/{all_prev}bottom_bar"

top_preloaded_images = thesystem.system.load_or_cache_images(top_images, (1229, 47), job, type_="top")
bottom_preloaded_images = thesystem.system.load_or_cache_images(bottom_images, (1229, 47), job, type_="bottom")

subprocess.Popen([sys.executable, thesystem.misc.resource_path('Files/Mod/default/sfx.py')])

thesystem.system.animate_window_open(window, target_height, window_width, step=50, delay=1)

window.configure(bg = "#FFFFFF")
set_data=thesystem.misc.return_settings()
transp_value=set_data["Settings"]["Transparency"]

window.attributes('-alpha',transp_value)
window.overrideredirect(True)
window.wm_attributes("-topmost", True)

soul_count=castle_data["Souls"]
xp_count=castle_data["XP"]
rewards=castle_data["Rewards"]
final=castle_data["Final"]

if soul_count>=10000 and rewards==False:
    with open("Files/Data/Demon_Castle.json", 'w') as castle_file:
        castle_data["Rewards"]=True
        ujson.dump(castle_data,castle_file, indent=4)
    
    thesystem.castle.reward_castle()

def start_move(event):
    window.lastx, window.lasty = event.widget.winfo_pointerxy()

def move_window(event):
    x_root, y_root = event.widget.winfo_pointerxy()
    deltax, deltay = x_root - window.lastx, y_root - window.lasty

    if deltax != 0 or deltay != 0:  # Update only if there is actual movement
        window.geometry(f"+{window.winfo_x() + deltax}+{window.winfo_y() + deltay}")
        window.lastx, window.lasty = x_root, y_root

def ex_close(win):
    global stop_animation
    stop_animation = True
    if setting_data["Settings"]["Performernce (ANIME):"] != "True":
        stop_event.set()
        update_thread.join()    
    with open("Files/Player Data/Tabs.json",'r') as tab_son:
        tab_son_data=ujson.load(tab_son)

    with open("Files/Player Data/Tabs.json",'w') as fin_tab_son:
        tab_son_data["Castle"]='Close'
        ujson.dump(tab_son_data,fin_tab_son,indent=4)
    threading.Thread(target=thesystem.system.fade_out, args=(window, 0.8)).start()
    subprocess.Popen([sys.executable, thesystem.misc.resource_path('Files/Mod/default/sfx_close.py')])
    thesystem.system.animate_window_close(window, initial_height, window_width, step=50, delay=1)

def ex_dc_close(win):
    global stop_animation
    stop_animation = True
    if setting_data["Settings"]["Performernce (ANIME):"] != "True":
        stop_event.set()
        update_thread.join()
    with open("Files/Player Data/Tabs.json",'r') as tab_son:
        tab_son_data=ujson.load(tab_son)

    with open("Files/Player Data/Tabs.json",'w') as fin_tab_son:
        tab_son_data["Castle"]='Close'
        ujson.dump(tab_son_data,fin_tab_son,indent=4)

    subprocess.Popen([sys.executable, thesystem.misc.resource_path('Anime Version/Demon Castle Quest Reminder/gui.py')])
    
    threading.Thread(target=thesystem.system.fade_out, args=(window, 0.8)).start()
    subprocess.Popen([sys.executable, thesystem.misc.resource_path('Files/Mod/default/sfx_close.py')])
    thesystem.system.animate_window_close(window, initial_height, window_width, step=50, delay=1)

canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 602,
    width = 1102,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
image_image_1 = PhotoImage(
    file=relative_to_assets("background.png"))
image_1 = canvas.create_image(
    961.0,
    329.0,
    image=image_image_1
)

with open("Files/Mod/presets.json", 'r') as pres_file:
    pres_file_data=ujson.load(pres_file)
    video_path=pres_file_data["Anime"][video]
    preloaded_frames = np.load(video_path)
player = thesystem.system.FastVideoPlayer(canvas, preloaded_frames, 478.0, 277.0, pause_duration=1.0)

image_image_2 = PhotoImage(
    file=relative_to_assets("frame.png"))
image_2 = canvas.create_image(
    554.0,
    319.0,
    image=image_image_2
)

# =================================================================

image_image_4 = PhotoImage(
    file=relative_to_assets("image_5.png"))
image_4 = canvas.create_image(
    622.0,
    465.0,
    image=image_image_4,
    state="hidden"
)

image_image_5 = PhotoImage(
    file=relative_to_assets("image_5.png"))
image_5 = canvas.create_image(
    666.0,
    443.0,
    image=image_image_5,
    state="hidden"
)

image_image_6 = PhotoImage(
    file=relative_to_assets("image_6.png"))
image_6 = canvas.create_image(
    666.0,
    490.0,
    image=image_image_6,
    state="hidden"
)

image_image_7 = PhotoImage(
    file=relative_to_assets("image_7.png"))
image_7 = canvas.create_image(
    585.0,
    416.0,
    image=image_image_7,
    state="hidden"
)

image_image_8 = PhotoImage(
    file=relative_to_assets("image_8.png"))
image_8 = canvas.create_image(
    641.0,
    404.0,
    image=image_image_8,
    state="hidden"
)

image_image_9 = PhotoImage(
    file=relative_to_assets("image_9.png"))
image_9 = canvas.create_image(
    541.0,
    358.0,
    image=image_image_9,
    state="hidden"
)

image_image_10 = PhotoImage(
    file=relative_to_assets("image_10.png"))
image_10 = canvas.create_image(
    643.0,
    347.0,
    image=image_image_10,
    state="hidden"
)

image_image_11 = PhotoImage(
    file=relative_to_assets("image_11.png"))
image_11 = canvas.create_image(
    680.0,
    387.0,
    image=image_image_11,
    state="hidden"
)

image_image_12 = PhotoImage(
    file=relative_to_assets("image_12.png"))
image_12 = canvas.create_image(
    662.0,
    312.0,
    image=image_image_12,
    state="hidden"
)

image_image_13 = PhotoImage(
    file=relative_to_assets("image_13.png"))
image_13 = canvas.create_image(
    587.0,
    347.0,
    image=image_image_13,
    state="hidden"
)

image_image_14 = PhotoImage(
    file=relative_to_assets("image_14.png"))
image_14 = canvas.create_image(
    543.0,
    299.0,
    image=image_image_14,
    state="hidden"
)

image_image_15 = PhotoImage(
    file=relative_to_assets("image_15.png"))
image_15 = canvas.create_image(
    620.0,
    297.0,
    image=image_image_15,
    state="hidden"
)

image_image_16 = PhotoImage(
    file=relative_to_assets("image_16.png"))
image_16 = canvas.create_image(
    583.0,
    265.0,
    image=image_image_16,
    state="hidden"
)

image_image_17 = PhotoImage(
    file=relative_to_assets("image_17.png"))
image_17 = canvas.create_image(
    553.0,
    234.0,
    image=image_image_17,
    state="hidden"
)

image_image_18 = PhotoImage(
    file=relative_to_assets("image_18.png"))
image_18 = canvas.create_image(
    618.0,
    236.0,
    image=image_image_18,
    state="hidden"
)

image_image_19 = PhotoImage(
    file=relative_to_assets("image_19.png"))
image_19 = canvas.create_image(
    589.0,
    196.0,
    image=image_image_19,
    state="hidden"
)

image_image_20 = PhotoImage(
    file=relative_to_assets("image_20.png"))
image_20 = canvas.create_image(
    614.0,
    156.0,
    image=image_image_20,
    state="hidden"
)

image_image_21 = PhotoImage(
    file=relative_to_assets("image_21.png"))
image_21 = canvas.create_image(
    643.0,
    196.0,
    image=image_image_21,
    state="hidden"
)

image_image_22 = PhotoImage(
    file=relative_to_assets("image_22.png"))
image_22 = canvas.create_image(
    664.0,
    120.0,
    image=image_image_22,
    state="hidden"
)

image_image_23 = PhotoImage(
    file=relative_to_assets("image_23.png"))
image_23 = canvas.create_image(
    689.0,
    183.0,
    image=image_image_23,
    state="hidden"
)

image_image_24 = PhotoImage(
    file=relative_to_assets("image_24.png"))
image_24 = canvas.create_image(
    707.0,
    147.0,
    image=image_image_24,
    state="hidden"
)

image_image_25 = PhotoImage(
    file=relative_to_assets("image_25.png"))
image_25 = canvas.create_image(
    735.0,
    207.0,
    image=image_image_25,
    state="hidden"
)

image_image_26 = PhotoImage(
    file=relative_to_assets("image_26.png"))
image_26 = canvas.create_image(
    743.0,
    109.0,
    image=image_image_26,
    state="hidden"
)

image_image_27 = PhotoImage(
    file=relative_to_assets("image_27.png"))
image_27 = canvas.create_image(
    786.0,
    156.0,
    image=image_image_27,
    state="hidden"
)

image_image_28 = PhotoImage(
    file=relative_to_assets("image_28.png"))
image_28 = canvas.create_image(
    849.0,
    149.0,
    image=image_image_28,
    state="hidden"
)

image_image_29 = PhotoImage(
    file=relative_to_assets("image_29.png"))
image_29 = canvas.create_image(
    822.0,
    193.0,
    image=image_image_29,
    state="hidden"
)

image_image_30 = PhotoImage(
    file=relative_to_assets("image_30.png"))
image_30 = canvas.create_image(
    797.0,
    240.0,
    image=image_image_30,
    state="hidden"
)

image_image_31 = PhotoImage(
    file=relative_to_assets("image_31.png"))
image_31 = canvas.create_image(
    841.0,
    234.0,
    image=image_image_31,
    state="hidden"
)

image_image_32 = PhotoImage(
    file=relative_to_assets("image_32.png"))
image_32 = canvas.create_image(
    888.0,
    207.0,
    image=image_image_32,
    state="hidden"
)

image_image_33 = PhotoImage(
    file=relative_to_assets("image_33.png"))
image_33 = canvas.create_image(
    928.0,
    249.0,
    image=image_image_33,
    state="hidden"
)

image_image_34 = PhotoImage(
    file=relative_to_assets("image_34.png"))
image_34 = canvas.create_image(
    874.0,
    263.0,
    image=image_image_34,
    state="hidden"
)

image_image_35 = PhotoImage(
    file=relative_to_assets("image_35.png"))
image_35 = canvas.create_image(
    837.0,
    295.0,
    image=image_image_35,
    state="hidden"
)

image_image_36 = PhotoImage(
    file=relative_to_assets("image_36.png"))
image_36 = canvas.create_image(
    885.0,
    317.0,
    image=image_image_36,
    state="hidden"
)

image_image_37 = PhotoImage(
    file=relative_to_assets("image_37.png"))
image_37 = canvas.create_image(
    926.0,
    293.0,
    image=image_image_37,
    state="hidden"
)

image_image_38 = PhotoImage(
    file=relative_to_assets("image_38.png"))
image_38 = canvas.create_image(
    926.0,
    344.0,
    image=image_image_38,
    state="hidden"
)

image_image_39 = PhotoImage(
    file=relative_to_assets("image_39.png"))
image_39 = canvas.create_image(
    803.0,
    372.0,
    image=image_image_39,
    state="hidden"
)

image_image_40 = PhotoImage(
    file=relative_to_assets("image_40.png"))
image_40 = canvas.create_image(
    718.0,
    395.0,
    image=image_image_40,
    state="hidden"
)

image_image_41 = PhotoImage(
    file=relative_to_assets("image_41.png"))
image_41 = canvas.create_image(
    670.0,
    249.0,
    image=image_image_41,
    state="hidden"
)

image_image_42 = PhotoImage(
    file=relative_to_assets("image_42.png"))
image_42 = canvas.create_image(
    720.0,
    427.0,
    image=image_image_42,
    state="hidden"
)

image_image_43 = PhotoImage(
    file=relative_to_assets("image_43.png"))
image_43 = canvas.create_image(
    726.0,
    488.0,
    image=image_image_43,
    state="hidden"
)

image_image_44 = PhotoImage(
    file=relative_to_assets("image_44.png"))
image_44 = canvas.create_image(
    768.0,
    451.0,
    image=image_image_44,
    state="hidden"
)

image_image_45 = PhotoImage(
    file=relative_to_assets("image_45.png"))
image_45 = canvas.create_image(
    770.0,
    414.0,
    image=image_image_45,
    state="hidden"
)

image_image_46 = PhotoImage(
    file=relative_to_assets("image_46.png"))
image_46 = canvas.create_image(
    809.0,
    457.0,
    image=image_image_46,
    state="hidden"
)

image_image_47 = PhotoImage(
    file=relative_to_assets("image_47.png"))
image_47 = canvas.create_image(
    910.0,
    400.0,
    image=image_image_47,
    state="hidden"
)

image_image_48 = PhotoImage(
    file=relative_to_assets("image_48.png"))
image_48 = canvas.create_image(
    883.0,
    453.0,
    image=image_image_48,
    state="hidden"
)

image_image_49 = PhotoImage(
    file=relative_to_assets("image_49.png"))
image_49 = canvas.create_image(
    814.0,
    498.0,
    image=image_image_49,
    state="hidden"
)

image_image_50 = PhotoImage(
    file=relative_to_assets("image_50.png"))
image_50 = canvas.create_image(
    759.0,
    509.0,
    image=image_image_50,
    state="hidden"
)

image_image_51 = PhotoImage(
    file=relative_to_assets("image_51.png"))
image_51 = canvas.create_image(
    830.0,
    416.0,
    image=image_image_51,
    state="hidden"
)

image_image_52 = PhotoImage(
    file=relative_to_assets("image_52.png"))
image_52 = canvas.create_image(
    876.0,
    370.0,
    image=image_image_52,
    state="hidden"
)

image_image_53 = PhotoImage(
    file=relative_to_assets("image_53.png"))
image_53 = canvas.create_image(
    739.0,
    366.0,
    image=image_image_53,
    state="hidden"
)

side = PhotoImage(file=relative_to_assets("blue.png"))
if job.upper()!="NONE":
    side = PhotoImage(file=relative_to_assets("purple.png"))

canvas.create_image(0.0, 300.0, image=side)
canvas.create_image(1085.0, 310.0, image=side)

image_image_58 = PhotoImage(file=relative_to_assets("image_58.png"))
if job.upper()!="NONE":
    image_image_58 = PhotoImage(file=relative_to_assets("image_58_alt.png"))

image_58 = canvas.create_image(
    550.0,
    23.0,
    image=image_image_58
)

image_image_59 = PhotoImage(file=relative_to_assets("image_59.png"))
if job.upper()!="NONE":
    image_image_59 = PhotoImage(file=relative_to_assets("image_59_alt.png"))
image_59 = canvas.create_image(
    570.0,
    592.0,
    image=image_image_59
)

image_40 = thesystem.system.side_bar("left_bar.png", (63, 568))
canvas.create_image(0.0, 300.0, image=image_40)

image_50 = thesystem.system.side_bar("right_bar.png", (58, 550))
canvas.create_image(1075.0, 310.0, image=image_50)

image_index = 0
bot_image_index = 0 

top_current = top_preloaded_images[image_index]
top_image = canvas.create_image(
    550.0,
    25.0,
    image=top_preloaded_images[image_index]
)

canvas.tag_bind(top_image, "<ButtonPress-1>", start_move)
canvas.tag_bind(top_image, "<B1-Motion>", move_window)

bottom_image = canvas.create_image(
    570.0,
    580.0,
    image=bottom_preloaded_images[bot_image_index]
)

step,delay=1,1

stop_animation = False



def update_images():
    if stop_animation or not canvas.winfo_exists():
        return
    
    global image_index, bot_image_index

    image_index = (image_index + 1) % len(top_preloaded_images)
    top_img = top_preloaded_images[image_index]
    canvas.itemconfig(top_image, image=top_img)
    canvas.top_img = top_img

    bot_image_index = (bot_image_index + 1) % len(bottom_preloaded_images)
    bot_img = bottom_preloaded_images[bot_image_index]
    canvas.itemconfig(bottom_image, image=bot_img)
    canvas.bot_img = bot_img

    window.after(1000 // 24, update_images)

# Start the animation
if setting_data["Settings"]["Performernce (ANIME):"] != "True":
    update_thread = threading.Thread(target=update_images)
    update_thread.start()

# ===========================================================


# --- Global references to our main widgets ---
raid_widget = None

def start_raid(floor_num):
    """Hides the castle and shows the raid interface."""
    if castle_3d_widget and raid_widget:
        castle_3d_widget.place_forget()
        raid_widget.place(x=65, y=45, width=950, height=525)
        raid_widget.start(floor_num)

def end_raid():
    """Hides the raid interface and shows the castle."""
    if castle_3d_widget and raid_widget:
        raid_widget.place_forget()
        castle_3d_widget.place(x=50, y=50)
        
        # Reload the latest stats from the file
        player_stats = load_player_stats()["status"][0]
        highest_floor = player_stats.get("highest_floor", 0)

        # --- THIS IS THE FIX ---
        # Update the castle widget's internal variable with the new highest floor.
        castle_3d_widget.highest_floor_cleared = highest_floor
        
        # Set the camera to the next available floor (or the final floor if completed)
        next_floor = min(100, highest_floor + 1)
        castle_3d_widget.current_scroll_floor = next_floor
        castle_3d_widget.target_camera_y = castle_3d_widget.floors[next_floor - 1]['y_center']
        
        # Redraw the HUD with the correct "CLEARED" / "UNLOCKED" status
        castle_3d_widget.update_hud()



# Create the 3D castle widget
castle_3d_widget = Castle3D(window, width=1000, height=500)
castle_3d_widget.place(x=50, y=50)

# Create the Raid Interface but keep it hidden initially
raid_widget = RaidInterface(window, end_raid_callback=end_raid)

# Connect the castle's raid button to our new start_raid function
castle_3d_widget.raid_floor_callback = start_raid

# Bind the keys directly to the main window
window.bind("<KeyPress-Up>", castle_3d_widget.on_key_press)
window.bind("<KeyPress-Down>", castle_3d_widget.on_key_press)

button_image_1 = PhotoImage(
    file=relative_to_assets("close.png"))
button_1 = Button(
    image=button_image_1,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: ex_close(window),
    relief="flat"
)
button_1.place(
    x=1000.0,
    y=66.0,
    width=30.0,
    height=30.0
)


window.resizable(False, False)
window.mainloop()